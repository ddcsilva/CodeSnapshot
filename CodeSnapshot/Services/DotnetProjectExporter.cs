using System.Text;

namespace CodeSnapshot.Services;

public class DotnetProjectExporter : IProjectExporter
{
    private readonly string[] _validExtensions = [".cs", ".cshtml", ".json", ".config", ".xml", ".xaml", ".razor", ".csproj", ".sln", ".gitignore", ".editorconfig"];
    private readonly string[] _ignoredFolders = ["bin", "obj", ".vs", ".git", ".vscode", "node_modules", "packages", "dist", "build", "wwwroot"];
    private readonly string[] _ignoredFiles = ["*.user", "*.suo", "*.cache", "*.dll", "*.pdb", "*.exe", "*.zip", "*.nupkg"];

    public async Task<string> ExportAsync(string projectPath, string outputPath, Action<double> reportProgress, Action<string> log, CancellationToken cancellationToken)
    {
        try
        {
            if (!Directory.Exists(projectPath))
                throw new DirectoryNotFoundException($"Project directory not found: {projectPath}");

            if (!Directory.Exists(outputPath))
                Directory.CreateDirectory(outputPath);

            string projectName = Path.GetFileName(projectPath);
            string date = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
            string outputFile = Path.Combine(outputPath, $"snapshot-{projectName}-{date}.txt");

            if (File.Exists(outputFile))
                File.Delete(outputFile);

            var files = GetProjectFiles(projectPath);
            using var writer = new StreamWriter(outputFile, false, Encoding.UTF8);

            // Header
            await WriteHeaderAsync(writer, projectName, files.Count);
            await WriteTreeStructureAsync(writer, projectPath, 0, cancellationToken);
            await WriteFilesContentAsync(writer, files, projectPath, reportProgress, log, cancellationToken);

            return outputFile;
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            log($"Error during export: {ex.Message}");
            throw;
        }
    }

    private List<string> GetProjectFiles(string projectPath)
    {
        return Directory.GetFiles(projectPath, "*.*", SearchOption.AllDirectories)
            .Where(f =>
                _validExtensions.Contains(Path.GetExtension(f).ToLowerInvariant()) &&
                !_ignoredFolders.Any(ign => f.Contains(Path.DirectorySeparatorChar + ign + Path.DirectorySeparatorChar)) &&
                !_ignoredFiles.Any(ign => Path.GetFileName(f).MatchesPattern(ign)))
            .ToList();
    }

    private async Task WriteHeaderAsync(StreamWriter writer, string projectName, int fileCount)
    {
        await writer.WriteLineAsync("## Code Snapshot Report");
        await writer.WriteLineAsync($"Project: {projectName}");
        await writer.WriteLineAsync($"Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        await writer.WriteLineAsync($"Files: {fileCount}");
        await writer.WriteLineAsync($"Generated by: CodeSnapshot");
        await writer.WriteLineAsync();
    }

    private async Task WriteTreeStructureAsync(StreamWriter writer, string directory, int level, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        string folderName = Path.GetFileName(directory);
        string prefix = string.Concat(Enumerable.Repeat("│   ", level));
        await writer.WriteLineAsync($"{prefix}├── {folderName}");

        // Primeiro os diretórios
        foreach (var subDir in Directory.GetDirectories(directory).OrderBy(d => Path.GetFileName(d)))
        {
            var name = Path.GetFileName(subDir);
            if (_ignoredFolders.Contains(name)) continue;

            await WriteTreeStructureAsync(writer, subDir, level + 1, cancellationToken);
        }

        // Depois os arquivos
        var files = Directory.GetFiles(directory)
            .Where(f => _validExtensions.Contains(Path.GetExtension(f).ToLowerInvariant()) &&
                       !_ignoredFiles.Any(ign => Path.GetFileName(f).MatchesPattern(ign)))
            .OrderBy(f => Path.GetFileName(f));

        foreach (var file in files)
        {
            cancellationToken.ThrowIfCancellationRequested();
            string fileName = Path.GetFileName(file);
            await writer.WriteLineAsync($"{prefix}│   ├── {fileName}");
        }
    }

    private async Task WriteFilesContentAsync(StreamWriter writer, List<string> files, string projectPath, Action<double> reportProgress, Action<string> log, CancellationToken cancellationToken)
    {
        int total = files.Count;
        int count = 0;

        foreach (var file in files)
        {
            cancellationToken.ThrowIfCancellationRequested();

            count++;
            reportProgress((double)count / total);
            log($"{count * 100 / total}% - {Path.GetFileName(file)}");

            string relativePath = Path.GetRelativePath(projectPath, file);
            await writer.WriteLineAsync("\n" + new string('=', 80));
            await writer.WriteLineAsync($"File: {relativePath}");
            await writer.WriteLineAsync(new string('-', 80));

            try
            {
                var lines = await File.ReadAllLinesAsync(file, cancellationToken);
                foreach (var line in lines)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await writer.WriteLineAsync(line);
                }
            }
            catch (Exception ex)
            {
                await writer.WriteLineAsync($"Error reading file: {ex.Message}");
            }
        }
    }
}

public static class StringExtensions
{
    public static bool MatchesPattern(this string fileName, string pattern)
    {
        if (string.IsNullOrEmpty(pattern)) return false;
        if (pattern == "*") return true;

        string regexPattern = "^" + pattern
            .Replace(".", "\\.")
            .Replace("*", ".*")
            .Replace("?", ".")
            + "$";

        return System.Text.RegularExpressions.Regex.IsMatch(fileName, regexPattern);
    }
}
